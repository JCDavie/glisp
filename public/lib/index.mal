(defmacro! defn!
  (fn (name params body) `(def! ~name (fn ~params ~body))))

(defmacro! macroview (fn (expr)
	`(prn (macroexpand ~expr))
))

;; Conditionals
(defmacro! cond (fn (& xs)
	(if (> (count xs) 0)
		(list
			'if
			(first xs)
			(if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond"))
			(cons 'cond (rest (rest xs)))
		)
	)
))

;; Functioal Language Features
(defn! reduce (f init xs)
  (if (empty? xs) init (reduce f (f init (first xs)) (rest xs))))

(defn! foldr (f init xs)
  (if (empty? xs)
		init
		(f
			(first xs)
			(foldr f init (rest xs))
		)
	)
)

(defn! map [f xs]
	(foldr (fn [x acc] (cons (f x) acc)) () xs))

;; Math
(def! PI2 (* PI 2))

(defn! lerp (a b t) (+ b (* (- a b) t)))
(defn! degrees (radians) (/ (* radians 180) PI))
(defn! radians (degrees) (/ (* degrees PI) 180))

;; Logical
(defn! not (a) (if a false true))

;; Trivial
(defn! inc [x] (+ x 1))
(defn! dec [x] (- a 1))

(def! gensym (let [counter (atom 0)] (fn [] (symbol (str "G__" (swap! counter inc))))))

;; Graphical
(defmacro! set$ (fn (x) `(def! $ ~x)))

(set$ '(fill "red" (rect 0 0 100 100)))


(defn! color [& e]
	(let (l (count e))
		(cond
			(= l 1) e
			(= l 3) (str "rgba(" (nth e 0) "," (nth e 1) "," (nth e 2) ")")
			true "black"
		)
	)
)

(defn! translate [x y body] `("translate" ~x ~y ~body))
(defn! scale [x y body] `("scale" ~x ~y ~body))
(defn! rotate [a body] `("rotate" ~a ~body))

(defn! fill [color path] `("fill" ~color ~path))
(defn! stroke [color width path] `("stroke" ~color ~width ~path))

(defn! rect (x y w h)	`("rect" ~x ~y ~w ~h))
(defn! circle (x y r)	`("circle" ~x ~y ~r))
(defn! line (x1 y1 x2 y2)	`("line" ~x1 ~y1 ~x2 ~y2))
(defn! merge (p0 p1) `(~p0 ~p1))

(defn! _polyline (& pts)
	(if (< (count pts) 2)
		()
		(cons
			`("L" ~(first pts) ~(nth pts 1))
			(apply _polyline (rest (rest pts)))
		)
	)
)

(defn! polyline (& pts)
	(if (>= (count pts) 2)
		(concat
			["path"]
			(cons
				`("M" ~(first pts) ~(nth pts 1))
				(apply _polyline (rest (rest pts))))
		)
	)
)

