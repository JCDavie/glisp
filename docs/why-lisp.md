# なぜ Lisp なのか

## データとしてのコード

Glisp が多くのクリエイティブコーディング環境と違うのは、それが**手続き的**ではなく**宣言的**であるということです。こうしたスケッチがあるとします。

```clojure
(style (fill "salmon")
 (circle [100 100] 40))
```

Processing に慣れている方は、このような書き方のほうが馴染みがあるでしょう。

```js
fill('salmon')
circle(100, 100, 40)
```

それぞれの行は

- まず、塗りの色をサーモンに設定しなさい
- 次に、この中心と半径で円を描きなさい

という**手続き**として解釈することができます。一方で Glisp のコードは「ここにこういうものがあります」という**宣言**からなるデータの集まりとして読み下すほうが自然です。冒頭の例は、SVG を用いてこのように表現することもできます。

```svg
<g fill="salmon">
  <circle cx="100" cy="100" r="40">
</g>
```

そして実際に、Glisp のコードはある種の木構造からなるデータでもあります。

```
┬─ style
├─┬─ fill
│ └─ "salmon"
└─┬ circle
  ├─┬─ 100
  │ └─ 100
  └─ 40
```

これは **Code as Data（データとしてのコード）**という性質によるものです。Lisp では、コードとデータの区別をしません。なぜなら、コード自身もまたリストというデータから出来ているからです。
